== Schedulers and concurrency

When creating an RX API, it is key to realize that the threading model of your API and the
threading of the application consuming your API can be different and might interfere

. The threading model of your API is defined by the the APIs your implementation uses
. The threading model of the application is defined by the runtime hosting the application

here are a few examples:

- your API is implemented with a non-blocking event loop library
- your API is implemented with JDBC a thread blocking API
- the application runs in a main
- the application uses thread-per-request model in a servlet container
- the application runs in a non-blocking event loop server
- etc...

As API designer you have two responsibilities:

* understand the concurrency of your implementation
* properly document the concurrency of your API

=== Synchronous emissions

Synchronous emission happens when an `Emitter` is invoked during the subscription by the thread
that is called for the subscription

[source, java]
----
include::../../src/main/java/me/escoffier/lab/chapter6/Code1.java[]
----

Run this example, you should see:

[source, txt]
----
time thread      log
0    main        ---------------- Subscribing
24   main        Emitting: Superman
25   main        Received Superman
25   main        Emitting: Batman
25   main        Received Batman
25   main        Emitting: Aquaman
25   main        Received Aquaman
25   main        Emitting: Asterix
26   main        Received Asterix
26   main        Emitting: Captain America
26   main        Received Captain America
26   main        Completing
26   main        Complete
26   main        ---------------- Subscribed
----

We can see in this example

- the _main_ thread is the only one involved and all operations are executed on this thread
- each emission is followed exactly by its corresponding reception
- the next statement after the subscription operation happens after all the emissions

Synchronous emission is not much a problem when no latency is involved, i.e when the operations only
involve pure computation and don't involve operations that will pause the thread of execution.

However when an operations has a latency, the synchronous emission will impose this latency to the
subscribing thread like we can see in this example.

[source, java]
----
include::../../src/main/java/me/escoffier/lab/chapter6/Code2.java[]
----

Run this example, you should see:

[source, txt]
----
0    main        ---------------- Subscribing
58   main        Emitting: Superman
59   main        Received Superman
89   main        Emitting: Batman
89   main        Received Batman
121  main        Emitting: Aquaman
122  main        Received Aquaman
155  main        Emitting: Asterix
156  main        Received Asterix
189  main        Emitting: Captain America
189  main        Received Captain America
190  main        Completing
190  main        Complete
190  main        ---------------- Subscribed
----

It is exactly like the previous example, however we can see that the artificial delay in the emission
has is also happening in the application code that receives the items.

=== Asynchronous emissions

Asynchronous emission happens when an `Emitter` is invoked asynchronously by a different thread than
the subscription thread

[source, java]
----
include::../../src/main/java/me/escoffier/lab/chapter6/Code3.java[]
----

Run this example, you should see:

[source, txt]
----
time thread      log
0    main        ---------------- Subscribing
23   main        ---------------- Subscribed
23   Thread-0    Emitting: Superman
23   Thread-0    Received Superman
23   Thread-0    Emitting: Batman
24   Thread-0    Received Batman
24   Thread-0    Emitting: Aquaman
24   Thread-0    Received Aquaman
24   Thread-0    Emitting: Asterix
24   Thread-0    Received Asterix
24   Thread-0    Emitting: Captain America
25   Thread-0    Received Captain America
25   Thread-0    Completing
25   Thread-0    Complete
----

We can see in this example

- there are now two threads involved
- the _main_ thread that is the application thread
- the _Thread-0- thread that is the thread the API chose to use for emitting
- each emission is followed exactly by its corresponding reception (like before)
- the subscription is executed now quickly, before the actual observable completion happens

In this situation the application _main_ thread will not clearly be impacted by the API pauses, however some parts
of the application will be now executed on the _Thread-0_ thread.

If the application chooses to block, then the emitter thread will his turn be impacted by the blocking.

[source, java]
----
include::../../src/main/java/me/escoffier/lab/chapter6/Code4.java[]
----

Run this example, you should see:

[source, txt]
----
time thread      log
0    main        ---------------- Subscribing
23   main        ---------------- Subscribed
23   Thread-0    Emitting: Superman
58   Thread-0    Received Superman
58   Thread-0    Emitting: Batman
92   Thread-0    Received Batman
92   Thread-0    Emitting: Aquaman
125  Thread-0    Received Aquaman
125  Thread-0    Emitting: Asterix
159  Thread-0    Received Asterix
160  Thread-0    Emitting: Captain America
190  Thread-0    Received Captain America
190  Thread-0    Completing
223  Thread-0    Complete
----

- we have the same two threads like before
- pausing the application also pauses the API asynchronous emission thread

=== Scheduling operations

RxJava schedulers can change the behavior of the emitter and subscriber threads.

A scheduler is very similar to a Java `Executor`.

==== subscribeOn

The `subscribeOn` operation can change the emitter thread.

[source, java]
----
include::../../src/main/java/me/escoffier/lab/chapter6/Code5.java[]
----

Run this example, you should see:

[source, txt]
----
0    main            ---------------- Subscribing
25   main            ---------------- Subscribed
25   Scheduler-0     Emitting: Superman
26   Scheduler-0     Received Superman
26   Scheduler-0     Emitting: Batman
26   Scheduler-0     Received Batman
26   Scheduler-0     Emitting: Aquaman
26   Scheduler-0     Received Aquaman
26   Scheduler-0     Emitting: Asterix
27   Scheduler-0     Received Asterix
27   Scheduler-0     Emitting: Captain America
27   Scheduler-0     Received Captain America
27   Scheduler-0     Completing
27   Scheduler-0     Complete
----

We perform an asynchronous emission like before but instead of managing the thread directly
we use the `subscribeOn` operation to to execute the emitter's `subscribe` operation on the scheduler.

==== observeOn

The `observeOn` operations can change the suscriber thread.

[source, java]
----
include::../../src/main/java/me/escoffier/lab/chapter6/Code6.java[]
----

Run this example, you should see:

[source, txt]
----
0    main            ---------------- Subscribing
67   main            Emitting: Superman
68   main            Emitting: Batman
68   Scheduler-0     Received Superman
68   main            Emitting: Aquaman
68   Scheduler-0     Received Batman
68   main            Emitting: Asterix
68   Scheduler-0     Received Aquaman
69   main            Emitting: Captain America
69   Scheduler-0     Received Asterix
69   main            Completing
69   Scheduler-0     Received Captain America
70   main            ---------------- Subscribed
70   Scheduler-0     Complete
----

We perform a synchronous emission but the subscriber thread now executes on the scheduler thread
instead of the _main_ thread thanks to the `observeOn` operation.

==== Schedulers

In the examples we have used a scheduler backed by a fixed thread pool created from a Java executor.

There are different predefined schedulers by RxJava you can use too

- _Computation_ scheduler for computational work such as event-loops and callback processing
- _IO_ scheduler for IO bound operations
- _new Thread_ creates a new thread for each task
- _immediate_ run the task immediately

In addition if you are using Vert.x, it provides also schedulers as well to execute operations within Vert.x thread pools.

=== Schedulers in practice

Now let's see a couple of examples where we can directly apply schedulers to control the concurrency of our API.

In the first exercise we use the `java.net.HttpURLConnection` to achieve an HTTP request to the _Super Heroes Service_.

`HttpURLConnection` is certainly one of the worse way to do an HTTP request but it's a good example of an API that
blocks waiting for IO completions.

In `me.escoffier.lab.chapter6.Code7`, use the `subscribeOn`, to change the thread performing the HTTP requests.

[.assignment]
****
[source, java]
----
include::../../src/main/java/me/escoffier/lab/chapter6/Code7_Solution.java[]
----
****

You should get an output like:

[source]
----
0    main                          ---------------- Subscribing
8    main                          ---------------- Subscribed
163  Scheduler-0                   Emitting: Superman
164  Scheduler-0                   Received Superman
166  Scheduler-0                   Emitting: Batman
166  Scheduler-0                   Received Batman
169  Scheduler-0                   Emitting: Aquaman
169  Scheduler-0                   Received Aquaman
171  Scheduler-0                   Emitting: Captain America
171  Scheduler-0                   Received Captain America
171  Scheduler-0                   Completing
171  Scheduler-0                   Complete
----

The second exercise extends the first one but now we assume that the same code is used in an event-loop model.

For the example we use Vert.x, but the same reasoning would apply for other event-loop systems or even Android UI.

In `me.escoffier.lab.chapter6.Code8`, the subscription is performed on the Vert.x event-loop thread. Using a blocking
computation in this context is forbidden, in addition the subscriber expects to be notified on the *same* thread.

Use the `subscribeOn` and `observeOn` to avoid blocking the event loop and deliver the subscriber notifications
on the same event loop thread.

[.assignment]
****
[source, java]
----
include::../../src/main/java/me/escoffier/lab/chapter6/Code8_Solution.java[]
----
****

You should get an output like:

[source]
----
0    vert.x-eventloop-thread-0     ---------------- Subscribing
10   vert.x-eventloop-thread-0     ---------------- Subscribed
194  Scheduler-0                   Emitting: Superman
195  vert.x-eventloop-thread-0     Received Superman
197  Scheduler-0                   Emitting: Batman
198  vert.x-eventloop-thread-0     Received Batman
202  Scheduler-0                   Emitting: Aquaman
202  vert.x-eventloop-thread-0     Received Aquaman
203  Scheduler-0                   Emitting: Captain America
204  Scheduler-0                   Completing
204  vert.x-eventloop-thread-0     Received Captain America
204  vert.x-eventloop-thread-0     Complete
----

Notice that each emission is performed on the scheduler thread and each notification is performed on the
same thread that did the subscription.

=== Conclusion

We have seen that RxJava `subscribeOn` and `observeOn` are powerful tool for controlling the execution thread
of emissions and notifications. We used mainly the `Observable` type, but these applies to all
reactive types: `Single`, `Flowable`, `Completable` and `Maybe`.

Your API should be as much consistent as possible accross all reactive methods, to respect the principle of
least expectation.

An application requiring to be notified on a different thread, can always use `observeOn` to chose the
scheduler the notifications will take place on.

So when returning a reactive type, you *must* always document the thread the emissions will take place on as well
as the thread the notifications will take place on, to give the API user the opportunity to take this decision.

